** avrINT [[https://github.com/ricardocosme/avrINT/actions?query=workflow%3A%22avr-gcc+10.2%22][https://github.com/ricardocosme/avrINT/workflows/avr-gcc%2010.2/badge.svg?branch=main]]
C++11/17 component to use the interrupt capabilities of AVR. It can be thought as a C++ version to the C headers [[http://svn.savannah.gnu.org/viewvc/avr-libc/tags/avr-libc-2_0_0-release/include/avr/interrupt.h?revision=2516&view=markup][avr/interrupt.h]] and [[http://svn.savannah.gnu.org/viewvc/avr-libc/tags/avr-libc-2_0_0-release/include/util/atomic.h?revision=2516&view=markup][util/atomic.h]] from [[https://www.nongnu.org/avr-libc/][AVR Libc]].[[file:WHY.org][(Why?)]]

**** Demo

#+BEGIN_SRC C++
  #include <avr/interrupt.hpp>

  using namespace avr::interrupt;

  int main() {
      on(); //enable the global interrupts
      off(); //disable the global interrupts

      { //scope with code executed without being disturbed by interrupts
          atomic sa;
          //code
      } //global interrupts are always enabled in the end

      {
          atomic sa{restore};
          //code
      } //global interrupts are enabled in the end if they were enabled before
  }
#+END_SRC

The demo above uses C++17 but there is support to C++11, take a look at [[file:demo/c++11][demo/c++11]] to see how to use.

*** Facilities
Note, simplifications are taken into account in order to achieve a more expressive documentation, please, open [[file:include/avr/interrupt.hpp][avr/interrupt.hpp]] to see the real prototypes or declarations.

**** ~void on()~
**** ~void sei()~
Enable global interrupts.

**** ~void off()~
**** ~void cli()~
Disable global interrupts.

**** ~atomic::atomic(Restore = no_restore_t{})~
[[https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization][RAII]] to execute code without being disturbed by interrupts. If the argument ~restore~ is passed to the constructor then the state of the status register is recovered in the end of the scope, which means that global interrupts are enabled again only if they were enabled before.

**** ~AVRINT_IST(vector, ...)~
Macro to define ISR(Interrupt Service Routine) routines. The parameter ~vector~ is the name of the interrupt vector and the variable argument can be used to put additional attributes.

*** How to use it?
1. Add the ~include~ directory to your include path and the include patch to [[https://github.com/ricardocosme/avrIO][avrIO]](if you want to use it instead of ~avr/io.h~).
2. Add ~#include <avr/interrupt.hpp>~ to your source and enjoy it!

*** How to build the demos?
1. If you want to build the demos with support to C++11, then go to the directory ~demo/c++11~, if you want C++20 then go to ~demo/c++20~.
2. Inform the include path to [[https://github.com/ricardocosme/avrIO][avrIO]] if want to use it. Define the variable ~AVR_IO_INC~.
3. ~make~

*** Benchmark with AVR Libc

**** avrINT
#+BEGIN_SRC C++
void f() {
    avr::interrupt::on();
    avr::interrupt::off();
    avr::interrupt::atomic sa{avr::interrupt::restore};
    //code
}

/*
00000000 <_Z1fv>:
   0:	78 94       	sei
   2:	f8 94       	cli
   4:	8f b7       	in	r24, 0x3f	; 63
   6:	f8 94       	cli
   8:	8f bf       	out	0x3f, r24	; 63
   a:	08 95       	ret
*/
#+END_SRC
~-std=c++11 -Os  -mmcu=attiny13a~

**** AVR Libc
#+BEGIN_SRC C++
void f() {
    sei();
    cli();
    ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
        //code
    }
}

/*
00000000 <_Z1fv>:
   0:	78 94       	sei
   2:	f8 94       	cli
   4:	8f b7       	in	r24, 0x3f	; 63
   6:	f8 94       	cli
   8:	8f bf       	out	0x3f, r24	; 63
   a:	08 95       	ret
*/
}
#+END_SRC
~-std=c++17 -Os  -mmcu=attiny13a~

*** Requirements
1. ~avr-gcc~ with at least ~-std=c++11~.

*** Contributions
Contributions are welcome, if you like what you see and you have interest to help, don't hesitate to open a PR(pull request), a issue or contact me through my email.
